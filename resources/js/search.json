[[{"l":"Introduction"},{"l":"Description","p":["A simple package that allows you to write your API integrations or SDKs in a elegant way."]},{"i":"why","l":"Why?","p":["Building API integrations can be time consuming. After you have found an API client to use, you’re faced with lots of configuration to remember and it’s hard to repeat requests without copying and pasting. You’ll often find yourself writing the same boilerplate code over and over again.","We’ve standardised the way we talk to APIs with PSR-7, PSR-17 and PSR-18 but we haven’t got a standard structure to build API integrations."]},{"l":"Features","p":["Simple, easy to learn syntax that standardises the way you interact with APIs","Abstract API integrations into classes so you can keep your code DRY","Configuration is fast and can be shared across all your requests","PSR compliant.","Framework agnostic","Great for building your own PHP SDKs","Scalable with lots of API integrations across many team members"]}],[{"l":"Requirements","p":["This package requires:","PHP 7.2.5 or higher","A package that provides PSR-7 HTTP message implementation","A package that provides PSR-17 HTTP factory implementation","A package that provides PSR-18 HTTP client implementation"]}],[{"l":"Installation","p":["You can install the package via composer:","You should have at least one package that offers implementation for PSR-7, PSR-17 and PSR-18. Here are a few recommendations:","Guzzle· PSR-7, PSR-17 and PSR-18","Symfony HTTP Client· PSR-17 and PSR-18","nyholm/psr7· PSR-7 and PSR-17","Buzz· PSR-18"]}],[{"l":"Quickstart","p":["In this quickstart, we'll guide you through the most important functionalities of the package and how to use them.","First, you should install the package."]},{"l":"Create a Connector","p":["In order to send a request. You should create a Connector class that extends Jenky\\Atlas\\Connector class.","Additionally, you can set the request base URI by utilizing the baseUri method. If a relative URI is specified in the request endpoint method, the connector will merge the base URI with the relative URI, following the guidelines outlined in RFC 3986, section 5.2."]},{"l":"Creating Request","p":["Let's say you want to send a request to https://httpbin.org/headers. Create GetHeadersRequest class that extends the Jenky\\Atlas\\Request abstract class and set the uri in endpoint public method. That's all."]},{"l":"Sending Request","p":["Now you should be able to send the request:"]},{"l":"Inspecting response","p":["The request above will return an instance of Jenky\\Atlas\\Response, which provides a variety of methods that may be used to inspect the response:","You may be wondering where to find the HTTP client or how to customize it. In order to learn more about this topic, be sure to explore the next chapter, which delves into connectors, requests and responses."]}],[{"l":"Connectors","p":["From the Quick start guide, you have learned how to send a request without defining an HTTP client. However in real world use cases, typically you need to customize your HTTP client with options such as custom authorization header, timeout, etc..."]},{"l":"Writing Connectors","p":["All connectors extends the Jenky\\Atlas\\Connector abstract class which implements all the necessary methods to fulfill the Jenky\\Atlas\\Contracts\\ConnectorInterface contract. Within this class, you can create your own HTTP client, set up the pipeline to run middleware, and define default middleware."]},{"l":"Use Custom HTTP Client","p":["Within the defaultClient method, you should create your HTTP own client","Sometimes, as an end user, you can't use defaultClient method. However you can override the client by using withClient method","Then you can start sending your request.","This allows you to have constructor arguments on the connector, perfect for API tokens or configuration and also utilizes the powerful middleware pipeline feature.","Furthermore, it is possible to bind your connector to a PSR-11 container. By doing so, you can inject your connector into your service whenever you need to send requests."]},{"l":"Advanced Usage","p":["Please visit the Advanced chapter to explore additional usage of connector."]}],[{"l":"Requests","p":["Requests are classes that store all the information required to make a request. Within a request, you can define the connector, the HTTP Method (GET, POST, etc.) and the endpoint that you would like to make a request. You can also define headers and query parameters. Traditionally, you would write your HTTP requests each time you need to, but this way, you can write a request class once and use it multiple times in your application."]},{"l":"Making Requests","p":["Your request should extend the Jenky\\Atlas\\Request abstract class. After that, you should define the endpoint of the request by using endpoint method. In addition you can also set the HTTP method by using $method property."]},{"l":"Default Headers And Query Parameters","p":["Some requests require specific headers or query parameters to be sent. To define default headers on your request, you can extend the defaultHeaders method. For query parameters you can use defaultQuery method. These methods expect a keyed array to be returned."]},{"l":"Sending Data","p":["Most API integrations will often require sending data using a POST, PUT or PATCH request. You can use defaultBody method to do so. By default, data will be sent using the application/x-www-form-urlencoded content type."]},{"l":"JSON requests","p":["If you would like to send data using the application/json content type, you should add AsJson trait to your request:"]},{"l":"Multi-part requests","p":["If you would like to send files as multi-part requests, you should create your file using Jenky\\Atlas\\Body\\Multipart class. This class accept:","string the file aboslute path in the system.","Psr\\Http\\Message\\UploadedFileInterface instance.","SplFileInfo instance.","You can create your own multipart file to fit your application logic. It must implement the Jenky\\Atlas\\Contracts\\MultipartInterface."]},{"l":"Raw requests","p":["You may use the AsText trait if you would like to provide a raw request body when making a request:","Unlike AsJson or AsMutipart that set the content type automatically. When sending a raw request body, the content type header must be set manually.","Do not use multiple As... traits in your request."]},{"l":"Modifying Request","p":["Requests headers, query parameters and body can also be overwritten during runtime."]},{"l":"Using Constructor Arguments","p":["You will often have variables that you want to pass into the request. You may add your own properties to your request class or use a constructor to provide variables into the request instance. Since the request is still a regular class you may customise it how you like.","For example, I want to create a request to update an individual user by an ID. I will add a constructor to accept the user ID and I will concatenate the variable with the endpoint. This way I can pass the ID into every instance of the request."]},{"l":"Sending Requests","p":["Once you have the request instance, you can send it via connector like this:"]},{"l":"Sending Request without Connector","p":["While the typical setup of a connector and requests is great, sometimes all you need is to make a single request to a service. For scenarios like these, you may create a \" ConnectorlessRequest\" instead of making a connector and a single request. This saves you from having to create additional classes.","It is NOT recommended to send your requests without connector. Be aware of the downsides.","Create a request class, but instead of extending Jenky\\Atlas\\Request, you should extend Jenky\\Atlas\\ConnectorlessRequest. Next, just define everything else like you would a normal request. Make sure to include the full URL of the service you are integrating with.","As you don't have a connector for this request, you can use the send method directly on the request instance. This method works exactly the same as it would on the connector."]},{"l":"Downsides","p":["Not being able to have constructor arguments on your connector.","Not retryable.","Unable to add/remove middleware."]}],[{"l":"Responses","p":["All requests will return an instance of Jenky\\Atlas\\Response, which is a decorator of Psr\\Http\\Message\\ResponseInterface that provides a variety of convenience methods to inspect the response:"]},{"l":"Throwing Exceptions On Failures","p":["If you have a response instance and would like to throw an exception if the response status code indicates a client or server error, you may use the throw or throwIf methods:"]}],[{"l":"Middleware","p":["Middleware provide a convenient mechanism for inspecting and modifying HTTP requests before sending.","Additional middleware can be written to perform a variety of tasks. For example, a logging middleware might log all outgoing requests and responses."]},{"l":"Defining Middleware","p":["To create a new middleware, create a new callable class and put your logic inside __invoke method:","In this middleware, we will add a content type header to the request depends on the body type.","Middleware also can be a Closure:","You must call the $next callback with the $request to pass the request deeper into the middleware pipeline."]},{"i":"middleware--responses","l":"Middleware & Responses","p":["Of course, a middleware can perform tasks before or after sending the request. For example, the following middleware would perform some task before the request is sent by the client:","However, this middleware would perform its task after the request is sent:"]},{"l":"Registering Middleware"},{"l":"Default Middleware","p":["To register default middleware, list the middleware class in the defaultMiddleware method of your connector class."]},{"i":"adding--removing-middleware","l":"Adding & Removing Middleware","p":["Once the middleware has been created, you may use the push method to assign middleware to the pipeline:","Creating a middleware that modifies a request is made much simpler using the Jenky\\Atlas\\Middleware\\Interceptor::request() method. This middleware accepts a function that takes the request argument:","Modifying a response is also much simpler using the Jenky\\Atlas\\Middleware\\Interceptor::response() middleware:","You can give middleware a name, which allows you to add middleware before other named middleware, after other named middleware, or remove middleware by name."]}],[{"l":"Response Decoder","p":["HTTP response is a crucial aspect of web development, and it is essential to decode the response body to extract the necessary information. However, the response body is typically returned in a string format as JSON or XML, which can be challenging to work with. This is where a response decoder comes in handy. A response decoder can convert the HTTP response body from a string format to a more manageable format, such as an array. This conversion enables developers to extract the relevant information from the response quickly."]},{"l":"Configuring","p":["The decoder should be configured as per-request basis. By default Jenky\\Atlas\\Request uses ChainDecoder to decode the response body. Essentially, it iterates over a list of JsonDecoder and XmlDecoder and attempts to read the Content Type header to determine which one to use for decoding the body."]},{"l":"Creating Custom Decoder","p":["To create a custom decoder, you need to implement DecoderInterface which defines the structure that a decoder must have. The contract contains two methods: supports and decode where you can implement your own logic to decode the response body. Then you can start using it in your request."]}],[{"l":"Retrying Requests","p":["Sometimes you may deal with APIs that fail frequently because of network issues or temporary server errors. You may use the retry method to send a request and retry multiple times."]},{"l":"Getting Started","p":["In order to retry a failed requests, your connector must implements Jenky\\Atlas\\Contracts\\RetryableInterface interface and optionally add Jenky\\Atlas\\Traits\\Retryable trait to the connector. The retry method accepts the maximum number of times the request should be attempted and a retry strategy to decide if the request should be retried, and to define the waiting time between each retry."]},{"l":"Customising When a Retry Is Attempted","p":["By default, failed requests are retried up to 3 times, with an exponential delay between retries (first retry = 1 second; second retry: 2 seconds, third retry: 4 seconds) and only for the following HTTP status codes: 423, 425, 429, 502 and 503 when using any HTTP method and 500, 504, 507 and 510 when using an HTTP idempotent method.","If needed, you may pass a second argument to the retry method. The second argument is an instance of Jenky\\Atlas\\Contracts\\RetryStrategyInterface that determines if the retries should actually be attempted. This will retries the failed requests with a delay of 1 second."]},{"l":"Customising Delay","p":["You may also pass second and third arguments to the RetryCallback::when() method to customise the waiting time between each retry.","In the example above, failed requests are retried up to 3 times, with an exponential delay between retries (first retry = 1 second; second retry: 2 seconds, third retry: 4 seconds).","Instead of using an interval delay or calculated exponential delay, you may easily configure \"exponential\" backoffs by using withDelay() method. In this example, the retry delay will be 1 second for the first retry, 3 seconds for the second retry, and 10 seconds for the third retry:","As a SDK developer, you may set the default retry strategy by defining defaultRetryStrategy() method in the connector class."]},{"l":"Disabling Throwing Exceptions","p":["If a request fails, it will be attempted again - if it reaches the maximum number of errors, a RequestRetryFailedException will be thrown. If a request is successful at any point, it will return a Response instance.","If you would like to disable this behavior, you may provide a throw argument with a value of false. When disabled, the last response received by the client will be returned after all retries have been attempted:"]}],[{"l":"SDK"},{"l":"Creating SDK Connector"},{"l":"Using Connector","p":["Now that we have created the SDK class that extends the Jenky\\Atlas\\Connector class, all we need to do is instansiate it and provide the API authentication token."]},{"l":"Sending request","p":["When you have created the request, all that developers would need to do is to instantiate and send the request on the connector.","With this method, it’s really simple to build your SDK. All you would need to do is create all the requests and then document them in your README. Developers using your SDK can just instantiate your SDK and then use the send methods."]},{"l":"Sending Requests With Methods","p":["Sometimes you may want to make it easy for the developer to find all the methods that they need to call the API through your SDK. You can create methods on your connector which send an API request or you could write a \"resource\" class that contains lots of requests."]},{"l":"Using Request Resources","p":["The resource pattern can help you combine your SDK requests into simple groups that are easy for the developer to find and consume. The tutorial below will guide you through creating a resource class however you should customise it to your SDK."]},{"l":"Creating a Resource","p":["Let's start by creating a OrganizationResource class. This class should contain a constructor that passes in an instance of Jenky\\Atlas\\Contracts\\ConnectorInterface and additional constructor arguments that you need for all request grouped under the resource."]},{"l":"Defining a Resource On Your Connector","p":["Now we'll define a method on the connector which returns this resource class. Don't forget to pass the connector's instance ($this) into the resource."]},{"l":"Using the Resource","p":["Now all our users have to do is access the org() method on the SDK class to get access to all the various requests that our SDK has to offer."]}],[{"l":"Testing","p":["When testing HTTP clients, it is often necessary to simulate specific scenarios such as returning a successful response, returning an error, or returning specific responses in a certain order. However, hitting an actual remote API is not a good idea for unit tests as they need to be predictable, easy to bootstrap, and fast. This is because it can make your test run slower, waste rate limiting and even result in getting blocked by remote API.","Thanks to the PSR-18 Client and Atlas being client agnostic, testing has become much easier. You can now simply replace the underlying client with a mock client, eliminating the need to hit an actual remote API. Atlas provides a dedicated mock client for testing purposes, and you can find the full document on Atlas Mock Client."]}]]