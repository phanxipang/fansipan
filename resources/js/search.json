[[{"l":"Introduction"},{"l":"Description","p":["A simple package that allows you to write your API integrations or SDKs in a elegant way."]},{"i":"why","l":"Why?","p":["Building API integrations can be a time-consuming task. Once you have selected an API client to work with, you encounter the challenge of managing numerous configurations. Additionally, reusing requests without resorting to copying and pasting can be difficult. It is common to find yourself writing repetitive boilerplate code repeatedly throughout the integration process.","Tools such as PSR-7, PSR-17 and PSR-18 are great to build your API integrations. The only missing piece is how to effectively connect them together in a structured and clean manner."]},{"l":"Features","p":["Provides a simple, easy-to-learn, object-oriented syntax that standardizes the way you interact with APIs.","Abstract API integrations into classes so you can keep your code tidy and centralized.","Configuration is fast and can be shared across all your requests.","PSR compliant.","HTTP Client agnostic.","Reuseable middleware."]},{"l":"Credits","p":["PHP-FIG for their PSRs with special recognition to the authors and contributors of PSR-7 (HTTP message interfaces), PSR-17 (HTTP Factories) and PSR-18 (HTTP Client).","Guzzle for their URI resolver and middleware concept.","Sam C for his amazing Saloon package, which served as a source of inspiration.","HTTPlug Discovery."]}],[{"l":"Requirements","p":["This package requires:","PHP 7.2.5 or higher","A package that provides PSR-7 HTTP message implementation","A package that provides PSR-17 HTTP factory implementation","A package that provides PSR-18 HTTP client implementation"]}],[{"l":"Installation","p":["You can install the package via composer:","You should have at least one package that offers implementation for PSR-7, PSR-17 and PSR-18. Here are a few recommendations:","Guzzle· PSR-7, PSR-17 and PSR-18","Symfony HTTP Client· PSR-17 and PSR-18","nyholm/psr7· PSR-7 and PSR-17","Buzz· PSR-18"]}],[{"l":"Quickstart","p":["In this quickstart, we'll guide you through the most important functionalities of the package and how to use them.","First, you should install the package."]},{"l":"Create a Connector","p":["In order to send a request. You should create a Connector class that implements Fansipan\\Contracts\\ConnectorInterface interface and add Fansipan\\Traits\\ConnectorTrait trait to the connector to fullfil the contract interface.","Additionally, you can set the request base URI by utilizing the baseUri static method. If a relative URI is specified in the request endpoint method, the connector will merge the base URI with the relative URI, following the guidelines outlined in RFC 3986, section 5.2."]},{"l":"Creating Request","p":["Let's say you want to send a request to https://httpbin.org/headers. Create GetHeadersRequest class that extends the Fansipan\\Request abstract class and set the uri in endpoint public method. That's all."]},{"l":"Sending Request","p":["Now you should be able to send the request:"]},{"l":"Inspecting response","p":["The request above will return an instance of Fansipan\\Response, which provides a variety of methods that may be used to inspect the response:","You may be wondering where to find the HTTP client or how to customize it. In order to learn more about this topic, be sure to explore the next chapter, which delves into connectors, requests and responses."]}],[{"l":"Connectors","p":["From the Quick start guide, you have learned how to send a request without defining an HTTP client. However in real world use cases, typically you need to customize your HTTP client with options such as custom authorization header, timeout, etc..."]},{"l":"Writing Connectors","p":["Within your connector, you can create your own HTTP client, set up the pipeline to run middleware, and define default middleware."]},{"l":"Use Custom HTTP Client","p":["To create your own HTTP client, use the defaultClient method.","As an end-user, you can override the client by using withClient method","Then you can start sending your request.","This allows you to have constructor arguments on the connector, perfect for API tokens or configuration and also utilizes the powerful middleware pipeline feature.","Furthermore, it is possible to bind your connector to a PSR-11 container. By doing so, you can inject your connector into your service whenever you need to send requests."]},{"l":"Advanced Usage","p":["Please visit the Digging Deeper chapter to explore additional usage of connector."]}],[{"l":"Requests","p":["Requests are classes that store all the information required to make a request. Within a request, you can define the HTTP Method (GET, POST, etc.) and the endpoint that you would like to make a request. You can also define default headers and query parameters. Traditionally, you would write your HTTP requests each time you need to, but this way, you can write a request class once and use it multiple times in your application."]},{"l":"Making Requests","p":["Your request should extend the Fansipan\\Request abstract class. After that, you should define the endpoint of the request by using endpoint method. In addition you can also set the HTTP method by using method method, which defaults to GET.","Requests are mutable."]},{"l":"Default Headers And Query Parameters","p":["Some requests require specific headers or query parameters to be sent. To define default headers on your request, you can extend the defaultHeaders method. For query parameters you can use defaultQuery method. These methods expect a keyed array to be returned."]},{"l":"Sending Data","p":["Most API integrations will often require sending data using a POST, PUT or PATCH request. You can use defaultBody method to do so. By default, data will be sent using the application/x-www-form-urlencoded content type."]},{"l":"JSON requests","p":["If you would like to send data using the application/json content type, you should add AsJson trait to your request:"]},{"l":"Multi-part requests","p":["If you would like to send files as multi-part requests, you should create your file using Fansipan\\Body\\MultipartResource::from() static method. This method accepts:","resource stream.","string the file absolute path in the system.","Psr\\Http\\Message\\UploadedFileInterface instance.","SplFileObject instance.","You can also pass the second parameter as the filename and third parameter as content type of the file.","You can create your own multipart file to fit your application logic. It must implement the Fansipan\\Contracts\\MultipartInterface."]},{"l":"Raw requests","p":["You may use the AsText trait if you would like to provide a raw request body when making a request:","Unlike AsJson or AsMultipart that set the content type automatically. When sending a raw request body, the content type header must be set manually.","Do not use multiple As... traits in your request."]},{"l":"Using Constructor Arguments","p":["You will often have variables that you want to pass into the request. You may add your own properties to your request class or use a constructor to provide variables into the request instance. Since the request is still a regular class you may customise it how you like.","Let's consider an example where you need to create a request to update a specific user based on their ID. To achieve this, you can enhance the request by adding a constructor that accepts the user ID as a parameter. By concatenating the ID variable with the endpoint, you can ensure that the ID is passed to every instance of the request. This approach allows for a more streamlined and reusable implementation.","Another example is this endpoint, https://jsonplaceholder.typicode.com/todos, which supports the _page and _limit query parameters. Therefore, you should include something like this:","The flowing examples use PHP 8.1 syntax.","Likewise, if your endpoint has too many query strings for filtering, sorting, paging, etc., you should consider grouping them in their own dedicated value object instead of bloating the constructor."]},{"l":"Modifying Request","p":["Requests headers, query parameters and body can also be overwritten during runtime. However it is RECOMMENDED to setup your request using constructor arguments to avoid mutating the request object. This approach makes it easier for the user to know which parameters should be used for sending the request, rather than dealing with keys and values."]},{"l":"Sending Requests","p":["Once you have the request instance, you can send it via connector like this:"]},{"l":"Sending Request without Connector","p":["While the typical setup of a connector and requests is great, sometimes all you need is to make a single request to a service. For scenarios like these, you may create a \" ConnectorlessRequest\" instead of making a connector and a single request. This saves you from having to create additional classes.","It is NOT recommended to send your requests without connector. Be aware of the downsides.","Create a request class, but instead of extending Fansipan\\Request, you should extend Fansipan\\ConnectorlessRequest. Next, just define everything else like you would a normal request. Make sure to include the full URL of the service you are integrating with.","As you don't have a connector for this request, you can use the send method directly on the request instance. This method works exactly the same as it would on the connector."]},{"l":"Downsides","p":["Not being able to have constructor arguments on your connector.","Not retryable.","Unable to add/remove middleware."]}],[{"l":"Responses","p":["All requests will return an instance of Fansipan\\Response, which is a wrapper of Psr\\Http\\Message\\ResponseInterface that provides a variety of convenience methods to inspect the response:"]},{"l":"Throwing Exceptions On Failures","p":["If you have a response instance and would like to throw an exception if the response status code indicates a client or server error, you may use the throw or throwIf methods:"]}],[{"l":"Middleware","p":["Middleware provide a convenient mechanism for inspecting and modifying HTTP requests before sending.","Additional middleware can be written to perform a variety of tasks. For example, a logging middleware might log all outgoing requests and responses.","Middleware is mutable. If you want to apply middleware to only one request, use clone to avoid mutating the connector middleware."]},{"l":"Defining Middleware","p":["To create a new middleware, create a new Invokable class and put your logic inside __invoke method:","In this middleware, we will add a content type header to the request depends on the body type.","Middleware also can be a Closure:","You must call the $next callback with the $request to pass the request deeper into the middleware pipeline."]},{"i":"middleware--responses","l":"Middleware & Responses","p":["Of course, a middleware can perform tasks before or after sending the request. For example, the following middleware would perform some task before the request is sent by the client:","However, this middleware would perform its task after the request is sent:"]},{"l":"Registering Middleware"},{"l":"Default Middleware","p":["To register default middleware, list the middleware class in the defaultMiddleware method of your connector class."]},{"i":"adding--removing-middleware","l":"Adding & Removing Middleware","p":["Once the middleware has been created, you may use the push method to assign middleware to the pipeline:","Creating a middleware that modifies a request is made much simpler using the Fansipan\\Middleware\\Interceptor::request() method. This middleware accepts a function that takes the request argument:","Modifying a response is also much simpler using the Fansipan\\Middleware\\Interceptor::response() middleware:","You can give middleware a name, which allows you to add middleware before other named middleware, after other named middleware, or remove middleware by name."]}],[{"l":"Response Decoder","p":["HTTP response is a crucial aspect of web development, and it is essential to decode the response body to extract the necessary information. However, the response body is typically returned in a string format as JSON or XML, which can be challenging to work with. This is where a response decoder comes in handy. A response decoder can convert the HTTP response body from a string format to a more manageable format, such as an array. This conversion enables developers to extract the relevant information from the response quickly."]},{"l":"Configuring","p":["The decoder should be configured as per-request basis. By default Fansipan\\Request uses ChainDecoder to decode the response body. Essentially, it iterates over a list of JsonDecoder and XmlDecoder and attempts to read the Content Type header to determine which one to use for decoding the body."]},{"l":"Creating Custom Decoder","p":["To create a custom decoder, you need to implement DecoderInterface which defines the structure that a decoder must have. The contract contains only one method: decode where you can implement your own logic to decode the response body. Then you can start using it in your request."]}],[{"l":"Retrying Requests","p":["Sometimes you may deal with APIs that fail frequently because of network issues or temporary server errors. Fansipan has a useful built-in feature that allows you to send a request and retry multiple times."]},{"l":"Getting Started","p":["To retry a failed request, you should use the Fansipan\\ConnectorConfigurator to configure your connector for retrying the request. The retry method accepts the maximum number of times the request should be attempted, a retry strategy to decide if the request should be retried, and to define the waiting time between each retry."]},{"l":"Customising When a Retry Is Attempted","p":["By default, failed requests are retried up to 3 times, with an exponential delay between retries (first retry = 1 second; second retry: 2 seconds, third retry: 4 seconds) and only for the following HTTP status codes: 423, 425, 429, 502 and 503 when using any HTTP method and 500, 504, 507 and 510 when using an HTTP idempotent method.","If needed, you may pass a second argument to the retry method. It is an instance of Fansipan\\Contracts\\RetryStrategyInterface that determines if the retries should actually be attempted. This will retries the failed requests with a delay of 1 second."]},{"l":"Customising Delay","p":["You may also pass second and third arguments to the RetryCallback::when() method to customise the waiting time between each retry.","In the example above, failed requests are retried up to 3 times, with an exponential delay between retries (first retry = 1 second; second retry: 2 seconds, third retry: 4 seconds).","Instead of using an interval delay or calculated exponential delay, you may easily configure \"exponential\" backoffs by using withDelay() method. In this example, the retry delay will be 1 second for the first retry, 3 seconds for the second retry, and 10 seconds for the third retry:"]},{"l":"Disabling Throwing Exceptions","p":["If a request fails, it will be attempted again - if it reaches the maximum number of errors, a Fansipan\\Exception\\RequestRetryFailedException will be thrown. If a request is successful at any point, it will return a Fansipan\\Response instance.","If you would like to disable this behavior, you may provide a throw argument with a value of false. When disabled, the last response received by the client will be returned after all retries have been attempted:"]},{"l":"Retrying All Requests Globally","p":["Since middleware is mutable, adding new middleware means that all subsequent requests will also have it applied."]}],[{"l":"SDK"},{"l":"Creating SDK Connector"},{"l":"Using Connector","p":["Now that we have created the SDK connector class, all we need to do is instansiate it and provide the API authentication token."]},{"l":"Sending request","p":["When you have created the request, all that developers would need to do is to instantiate and send the request on the connector.","With this method, it’s really simple to build your SDK. All you would need to do is create all the requests and then document them in your README. Developers using your SDK can just instantiate your SDK and then use the send methods."]},{"l":"Sending Requests With Methods","p":["Sometimes you may want to make it easy for the developer to find all the methods that they need to call the API through your SDK. You can create methods on your connector which send an API request or you could write a \"resource\" class that contains lots of requests."]},{"l":"Using Request Resources","p":["The resource pattern can help you combine your SDK requests into simple groups that are easy for the developer to find and consume. The tutorial below will guide you through creating a resource class however you should customise it to your SDK."]},{"l":"Creating a Resource","p":["Let's start by creating a OrganizationResource class. This class should contain a constructor that passes in an instance of Fansipan\\Contracts\\ConnectorInterface and additional constructor arguments that you need for all request grouped under the resource."]},{"l":"Defining a Resource On Your Connector","p":["Now we'll define a method on the connector which returns this resource class. Don't forget to pass the connector's instance ($this) into the resource."]},{"l":"Using the Resource","p":["Now all our users have to do is access the org() method on the SDK class to get access to all the various requests that our SDK has to offer."]}],[{"l":"Testing","p":["When testing HTTP clients, it is often necessary to simulate specific scenarios such as returning a successful response, returning an error, or returning specific responses in a certain order. However, hitting an actual remote API is not a good idea for unit tests as they need to be predictable, easy to bootstrap, and fast. This is because it can make your test run slower, waste rate limiting and even result in getting blocked by remote API.","Thanks to the PSR-18 Client and Fansipan being client agnostic, testing has become much easier. You can now simply replace the underlying client with a mock client, eliminating the need to hit an actual remote API. Fansipan provides a dedicated mock client for testing purposes, and you can find the full document on Fansipan Mock Client."]}]]