[[{"l":"Introduction"},{"l":"Description","p":["A simple package that allows you to write your API integrations or SDKs in a elegant way."]},{"i":"why","l":"Why?","p":["Building API integrations can be time consuming. After you have found an API client to use, you’re faced with lots of configuration to remember and it’s hard to repeat requests without copying and pasting. You’ll often find yourself writing the same boilerplate code over and over again.","We’ve standardised the way we talk to APIs with PSR-7, PSR-17 and PSR-18 but we haven’t got a standard structure to build API integrations."]},{"l":"Features","p":["Simple, easy to learn syntax that standardises the way you interact with APIs","Abstract API integrations into classes so you can keep your code DRY","Configuration is fast and can be shared across all your requests","PSR compliant.","Framework agnostic","Great for building your own PHP SDKs","Scalable with lots of API integrations across many team members"]}],[{"l":"Requirements","p":["This package requires:","PHP 7.2.5 or higher","A package that provides PSR-7 HTTP message implementation","A package that provides PSR-17 HTTP factory implementation","A package that provides PSR-18 HTTP client implementation"]}],[{"l":"Installation","p":["You can install the package via composer:","You should have at least a package that provides PSR-7, PSR-17 and PSR-18 implementation. Here are few suggestions:","Guzzle· PSR-7, PSR-17 and PSR-18","Symfony HTTP Client· PSR-17 and PSR-18","nyholm/psr7· PSR-7 and PSR-17","Buzz· PSR-18"]}],[{"l":"Quickstart","p":["In this quickstart, we'll guide you through the most important functionalities of the package and how to use them.","First, you should install the package."]},{"l":"Flow Diagram"},{"l":"Create Request","p":["Let's say you want to send a request to https://httpbin.org/headers. Create GetHeadersRequest class that extends the Jenky\\Atlas\\Request abstract class and set the uri in endpoint public method. That's all.","Now you should be able to send the request:"]},{"l":"Inspect the response","p":["The request above will return an instance of Jenky\\Atlas\\Response, which provides a variety of methods that may be used to inspect the response:","You may wonder where is the client or how can I customize it? Be sure to explore the next chapter about connectors, requests and responses to find out more."]}],[{"l":"Connectors","p":["From the Quick start, you can send the request immediately without a HTTP client. However in real world use cases, typically you need to customize your HTTP client with options such as custom authorization header, timeout, etc..."]},{"l":"Writing Connectors","p":["All connectors extends Jenky\\Atlas\\Connector class. Within the defineClient method, you should create your HTTP own client.","defineClient method must return Psr\\Http\\Client\\ClientInterface implementation.","Then you can start using your connector from your request. This approach was very minimalist, but it introduced complexity and friction for the developer because you have to define a connector class on every request that you make.","It is recommended to send your requests through a connector like this:","This allows you to have constructor arguments on the connector, perfect for API tokens or configuration and also utilizes the powerful middleware pipeline feature.","In addition, you can also bind your connector to PSR-11 container so you don't have create a connector every time you want to send requests."]},{"l":"Advanced Usage","p":["Please visit the Advanced chapter to explore additional usage of connector."]}],[{"l":"Requests","p":["Requests are classes that store all the information required to make a request. Within a request, you can define the connector, the HTTP Method (GET, POST, etc.) and the endpoint that you would like to make a request. You can also define headers and query parameters. Traditionally, you would write your HTTP requests each time you need to, but this way, you can write a request class once and use it multiple times in your application."]},{"l":"Making Requests","p":["Your request should extend the Jenky\\Atlas\\Request abstract class. After that, you should define the endpoint of the request by using endpoint method. In addition you can also set the HTTP method by using $method property."]},{"l":"Specify The Connector","p":["Because connector contains your HTTP client instance and the middleware logic. Instead of using default connector, you can use your own connector by using $connector property.","Or if your appliation logic needs to overwrite the default MyConnector on the fly, you can do so by calling withConnector method before sending the request."]},{"l":"Default Headers And Query Parameters","p":["Some requests require specific headers or query parameters to be sent. To define default headers on your request, you can extend the defaultHeaders method. For query parameters you can use defaultQuery method. These methods expect a keyed array to be returned."]},{"l":"Sending Data","p":["Most API integrations will often require sending data using a POST, PUT or PATCH request. You can use defaultBody method to do so. By default, data will be sent using the application/x-www-form-urlencoded content type."]},{"l":"JSON requests","p":["If you would like to send data using the application/json content type, you should add AsJson trait to your request:"]},{"l":"Multi-part requests","p":["If you would like to send files as multi-part requests, you should create your file using Jenky\\Atlas\\Body\\Multipart class. This class accept:","string the file aboslute path in the system.","Psr\\Http\\Message\\UploadedFileInterface instance.","SplFileInfo instance.","You can create your own multipart file to fit your application logic. It must implement the Jenky\\Atlas\\Contracts\\MultipartInterface."]},{"l":"Raw requests","p":["You may use the AsText trait if you would like to provide a raw request body when making a request:","Unlike AsJson or AsMutipart that set the content type automatically. When sending a raw request body, the content type header must be set manually.","Do not use multiple As... traits in your request."]},{"l":"Modifying Request","p":["Requests headers, query parameters and body can also be overwritten during runtime."]},{"l":"Using Constructor Arguments","p":["You will often have variables that you want to pass into the request. You may add your own properties to your request class or use a constructor to provide variables into the request instance. Since the request is still a regular class you may customise it how you like.","For example, I want to create a request to update an individual user by an ID. I will add a constructor to accept the user ID and I will concatenate the variable with the endpoint. This way I can pass the ID into every instance of the request."]}],[{"l":"Responses","p":["All requests will return an instance of Jenky\\Atlas\\Response, which is a decorator of Psr\\Http\\Message\\ResponseInterface that provides a variety of convenience methods to inspect the response:"]},{"l":"Throwing Exceptions On Failures","p":["If you have a response instance and would like to throw an exception if the response status code indicates a client or server error, you may use the throw or throwIf methods:"]},{"i":"casting-to-data-transfer-objects-dtos","l":"Casting To Data Transfer Objects (DTOs)","p":["You may wish to cast the data you receive in an API response to a data transfer object (DTO)."]},{"l":"Configuring","p":["The DTO should be configured as per-request basis. Firstly, your request class should implement the Jenky\\Atlas\\Contracts\\DtoSerializable interface.","Then defines a required toDto method, you can also use the $response to inspect your data."]},{"l":"Retrieving your DTO","p":["Finally, when you retrieve a successful response from the API, you can use the dto method on the response to get the fully constructed DTO.","The response will only casted to your DTO if it was successful."]}],[{"l":"Middleware","p":["Middleware provide a convenient mechanism for inspecting and modifying HTTP requests before sending.","Additional middleware can be written to perform a variety of tasks. For example, a logging middleware might log all outgoing requests and responses."]},{"l":"Defining Middleware","p":["To create a new middleware, create a new class and put your logic inside __invoke method:","In this middleware, we will add a content type header to the request depends on the body type.","Middleware also can be a Closure:","You must call the $next callback with the $request to pass the request deeper into the middleware pipeline."]},{"i":"middleware--responses","l":"Middleware & Responses","p":["Of course, a middleware can perform tasks before or after sending the request. For example, the following middleware would perform some task before the request is sent by the client:","However, this middleware would perform its task after the request is sent:"]},{"l":"Registering Middleware"},{"l":"Default Middleware","p":["To register default middleware, list the middleware class in the defaultMiddleware method of your connector class."]},{"i":"adding--removing-middleware","l":"Adding & Removing Middleware","p":["Once the middleware has been created, you may use the push method to assign middleware to the pipeline:","Creating a middleware that modifies a request is made much simpler using the Jenky\\Atlas\\Middleware\\Interceptor::request() method. This middleware accepts a function that takes the request argument:","Modifying a response is also much simpler using the Jenky\\Atlas\\Middleware\\Interceptor::response() middleware:","You can give middleware a name, which allows you to add middleware before other named middleware, after other named middleware, or remove middleware by name."]}],[{"l":"SDK"},{"l":"Creating SDK Connector"},{"l":"Using Connector","p":["Now that we have created the SDK class that extends the Jenky\\Atlas\\Connector class, all we need to do is instansiate it and provide the API authentication token."]},{"l":"Sending request","p":["When you have created the request, all that developers would need to do is run it! You can use the send method to send a request straight away, or the request method to instantiate the request."]},{"l":"Using Request Collection","p":["Alternatively, you can define request classes and groups of requests on your connector class by using the $requests property to define requests. By using this method, you will have to register your API routes, but then developers can use methods to make API calls. To enable request collection for a connector, add the Jenky\\Atlas\\Traits\\HasRequestCollection trait to the connector:","The connector will create a \"magic\" method for the request based on its name in camelCase. For example, our registered GetRepository class will now have a method for it on the connector called getRepository(). When you call this method, GetRepository class will be instantiated."]},{"l":"Customising The Request Methods","p":["Sometimes you may want to use your own method names for requests on your connector. If you would like to do this, just add a key for the request to rename the method."]},{"l":"Groupping Requests","p":["You can also have many requests in an SDK, each separated into their own groups. For example, a \"repos\" group and a \"orgs\" group containing different requests.","Your requests now will be nested in a key that represents group name which also a method to access that group from the connector."]}]]