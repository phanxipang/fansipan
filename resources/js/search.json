[[{"l":"Introduction"},{"l":"Description","p":["A simple package that allows you to write your API integrations or SDKs in a elegant way."]},{"i":"why","l":"Why?","p":["Building API integrations can be time consuming. After you have found an API client to use, you’re faced with lots of configuration to remember and it’s hard to repeat requests without copying and pasting. You’ll often find yourself writing the same boilerplate code over and over again.","We’ve standardised the way we talk to APIs with PSR-7, PSR-17 and PSR-18 but we haven’t got a standard structure to build API integrations."]},{"l":"Features","p":["Simple, easy to learn syntax that standardises the way you interact with APIs","Abstract API integrations into classes so you can keep your code DRY","Configuration is fast and can be shared across all your requests","PSR compliant.","Framework agnostic","Great for building your own PHP SDKs","Scalable with lots of API integrations across many team members"]}],[{"l":"Requirements","p":["This package requires:","PHP 7.2.5 or higher","A package that provides PSR-7 HTTP message implementation","A package that provides PSR-17 HTTP factory implementation","A package that provides PSR-18 HTTP client implementation"]}],[{"l":"Installation","p":["You can install the package via composer:","You should have at least a package that provides PSR-7, PSR-17 and PSR-18 implementation. Here are few suggestions:","Guzzle· PSR-7, PSR-17 and PSR-18","Symfony HTTP Client· PSR-17 and PSR-18","nyholm/psr7· PSR-7 and PSR-17","Buzz· PSR-18"]}],[{"l":"Quickstart","p":["In this quickstart, we'll guide you through the most important functionalities of the package and how to use them.","First, you should install the package."]},{"l":"Flow Diagram"},{"l":"Create a Connector","p":["In order to send a request. First, you should create a Connector class that extends Jenky\\Atlas\\Connector class.","You may also set the request base uri by using baseUri() method. When a relative URI is provided to in request endpoint() method, the connector will combine the base URI with the relative URI using the rules described in RFC 3986, section 5.2."]},{"l":"Create a Request","p":["Let's say you want to send a request to https://httpbin.org/headers. Create GetHeadersRequest class that extends the Jenky\\Atlas\\Request abstract class and set the uri in endpoint public method. That's all."]},{"l":"Send the Request","p":["Now you should be able to send the request:"]},{"l":"Inspect the response","p":["The request above will return an instance of Jenky\\Atlas\\Response, which provides a variety of methods that may be used to inspect the response:","You may wonder where is the client or how can I customize it? Be sure to explore the next chapter about connectors, requests and responses to find out more."]}],[{"l":"Connectors","p":["From the Quick start, you can send the request immediately without a HTTP client. However in real world use cases, typically you need to customize your HTTP client with options such as custom authorization header, timeout, etc..."]},{"l":"Writing Connectors","p":["All connectors extends Jenky\\Atlas\\Connector class."]},{"l":"Use Custom HTTP Client","p":["Within the defineClient method, you should create your HTTP own client","Sometimes, as an end user, you can't use defineClient method. However you can override the client by using withClient method","Then you can start sending your request.","This allows you to have constructor arguments on the connector, perfect for API tokens or configuration and also utilizes the powerful middleware pipeline feature.","In addition, you can also bind your connector to PSR-11 container so you don't have create a connector every time you want to send requests."]},{"l":"Advanced Usage","p":["Please visit the Advanced chapter to explore additional usage of connector."]}],[{"l":"Requests","p":["Requests are classes that store all the information required to make a request. Within a request, you can define the connector, the HTTP Method (GET, POST, etc.) and the endpoint that you would like to make a request. You can also define headers and query parameters. Traditionally, you would write your HTTP requests each time you need to, but this way, you can write a request class once and use it multiple times in your application."]},{"l":"Making Requests","p":["Your request should extend the Jenky\\Atlas\\Request abstract class. After that, you should define the endpoint of the request by using endpoint method. In addition you can also set the HTTP method by using $method property."]},{"l":"Default Headers And Query Parameters","p":["Some requests require specific headers or query parameters to be sent. To define default headers on your request, you can extend the defaultHeaders method. For query parameters you can use defaultQuery method. These methods expect a keyed array to be returned."]},{"l":"Sending Data","p":["Most API integrations will often require sending data using a POST, PUT or PATCH request. You can use defaultBody method to do so. By default, data will be sent using the application/x-www-form-urlencoded content type."]},{"l":"JSON requests","p":["If you would like to send data using the application/json content type, you should add AsJson trait to your request:"]},{"l":"Multi-part requests","p":["If you would like to send files as multi-part requests, you should create your file using Jenky\\Atlas\\Body\\Multipart class. This class accept:","string the file aboslute path in the system.","Psr\\Http\\Message\\UploadedFileInterface instance.","SplFileInfo instance.","You can create your own multipart file to fit your application logic. It must implement the Jenky\\Atlas\\Contracts\\MultipartInterface."]},{"l":"Raw requests","p":["You may use the AsText trait if you would like to provide a raw request body when making a request:","Unlike AsJson or AsMutipart that set the content type automatically. When sending a raw request body, the content type header must be set manually.","Do not use multiple As... traits in your request."]},{"l":"Modifying Request","p":["Requests headers, query parameters and body can also be overwritten during runtime."]},{"l":"Using Constructor Arguments","p":["You will often have variables that you want to pass into the request. You may add your own properties to your request class or use a constructor to provide variables into the request instance. Since the request is still a regular class you may customise it how you like.","For example, I want to create a request to update an individual user by an ID. I will add a constructor to accept the user ID and I will concatenate the variable with the endpoint. This way I can pass the ID into every instance of the request."]},{"l":"Sending Requests","p":["Once you have the request instance, you can send it via connector like this:"]},{"l":"Sending Request without Connector","p":["While the typical setup of a connector and requests is great, sometimes all you need is to make a single request to a service. For scenarios like these, you may create a \" ConnectorlessRequest\" instead of making a connector and a single request. This saves you from having to create additional classes.","It is NOT recommended to send your requests without connector. Be aware of the downsides.","Create a request class, but instead of extending Jenky\\Atlas\\Request, you should extend Jenky\\Atlas\\ConnectorlessRequest. Next, just define everything else like you would a normal request. Make sure to include the full URL of the service you are integrating with.","As you don't have a connector for this request, you can use the send method directly on the request instance. This method works exactly the same as it would on the connector."]},{"l":"Downsides","p":["Not being able to have constructor arguments on your connector.","Not retryable.","Unable to add/remove middleware."]}],[{"l":"Responses","p":["All requests will return an instance of Jenky\\Atlas\\Response, which is a decorator of Psr\\Http\\Message\\ResponseInterface that provides a variety of convenience methods to inspect the response:"]},{"l":"Throwing Exceptions On Failures","p":["If you have a response instance and would like to throw an exception if the response status code indicates a client or server error, you may use the throw or throwIf methods:"]},{"i":"casting-to-data-transfer-objects-dtos","l":"Casting To Data Transfer Objects (DTOs)","p":["While working with API, you may wish to cast the data you receive in an API response to a data transfer object (DTO)."]},{"l":"Configuring","p":["The DTO should be configured as per-request basis. Firstly, your request class should implement the Jenky\\Atlas\\Contracts\\DtoSerializable interface.","Then defines a required toDto method, you can also use the $response to inspect your data."]},{"l":"Retrieving your DTO","p":["Finally, when you retrieve a successful response from the API, you can use the dto method on the response to get the fully constructed DTO.","The response will only casted to your DTO if it was successful."]}],[{"l":"Middleware","p":["Middleware provide a convenient mechanism for inspecting and modifying HTTP requests before sending.","Additional middleware can be written to perform a variety of tasks. For example, a logging middleware might log all outgoing requests and responses."]},{"l":"Defining Middleware","p":["To create a new middleware, create a new class and put your logic inside __invoke method:","In this middleware, we will add a content type header to the request depends on the body type.","Middleware also can be a Closure:","You must call the $next callback with the $request to pass the request deeper into the middleware pipeline."]},{"i":"middleware--responses","l":"Middleware & Responses","p":["Of course, a middleware can perform tasks before or after sending the request. For example, the following middleware would perform some task before the request is sent by the client:","However, this middleware would perform its task after the request is sent:"]},{"l":"Registering Middleware"},{"l":"Default Middleware","p":["To register default middleware, list the middleware class in the defaultMiddleware method of your connector class."]},{"i":"adding--removing-middleware","l":"Adding & Removing Middleware","p":["Once the middleware has been created, you may use the push method to assign middleware to the pipeline:","Creating a middleware that modifies a request is made much simpler using the Jenky\\Atlas\\Middleware\\Interceptor::request() method. This middleware accepts a function that takes the request argument:","Modifying a response is also much simpler using the Jenky\\Atlas\\Middleware\\Interceptor::response() middleware:","You can give middleware a name, which allows you to add middleware before other named middleware, after other named middleware, or remove middleware by name."]}],[{"l":"Retrying Requests","p":["Sometimes you may deal with APIs that fail frequently because of network issues or temporary server errors. You may use the retry method to send a request and retry multiple times."]},{"l":"Getting Started","p":["In order to retry a failed requests, your connector must implements Jenky\\Atlas\\Contracts\\RetryableInterface interface and optionally add Jenky\\Atlas\\Traits\\Retryable trait to the connector. The retry method accepts the maximum number of times the request should be attempted and a retry strategy to decide if the request should be retried, and to define the waiting time between each retry."]},{"l":"Customising When a Retry Is Attempted","p":["By default, failed requests are retried up to 3 times, with an exponential delay between retries (first retry = 1 second; second retry: 2 seconds, third retry: 4 seconds) and only for the following HTTP status codes: 423, 425, 429, 502 and 503 when using any HTTP method and 500, 504, 507 and 510 when using an HTTP idempotent method.","If needed, you may pass a second argument to the retry method. The second argument is an instance of Jenky\\Atlas\\Contracts\\RetryStrategyInterface that determines if the retries should actually be attempted. This will retries the failed requests with a delay of 1 second."]},{"l":"Customising Delay","p":["You may also pass second and third arguments to the RetryCallback::when() method to customise the waiting time between each retry.","In the example above, failed requests are retried up to 3 times, with an exponential delay between retries (first retry = 1 second; second retry: 2 seconds, third retry: 4 seconds).","Instead of using an interval delay or calculated exponential delay, you may easily configure \"exponential\" backoffs by using withDelay() method. In this example, the retry delay will be 1 second for the first retry, 3 seconds for the second retry, and 10 seconds for the third retry:","As a SDK developer, you may set the default retry strategy by defining defaultRetryStrategy() method in the connector class."]},{"l":"Disabling Throwing Exceptions","p":["If a request fails, it will be attempted again - if it reaches the maximum number of errors, a RequestRetryFailedException will be thrown. If a request is successful at any point, it will return a Response instance.","If you would like to disable this behavior, you may provide a throw argument with a value of false. When disabled, the last response received by the client will be returned after all retries have been attempted:"]}],[{"l":"SDK"},{"l":"Creating SDK Connector"},{"l":"Using Connector","p":["Now that we have created the SDK class that extends the Jenky\\Atlas\\Connector class, all we need to do is instansiate it and provide the API authentication token."]},{"l":"Sending request","p":["When you have created the request, all that developers would need to do is to instantiate and send the request on the connector.","With this method, it’s really simple to build your SDK. All you would need to do is create all the requests and then document them in your README. Developers using your SDK can just instantiate your SDK and then use the send methods."]},{"l":"Sending Requests With Methods","p":["Sometimes you may want to make it easy for the developer to find all the methods that they need to call the API through your SDK. You can create methods on your connector which send an API request or you could write a \"resource\" class that contains lots of requests."]},{"l":"Using Request Resources","p":["The resource pattern can help you combine your SDK requests into simple groups that are easy for the developer to find and consume. The tutorial below will guide you through creating a resource class however you should customise it to your SDK."]},{"l":"Creating a Resource","p":["Let's start by creating a OrganizationResource class. This class should contain a constructor that passes in an instance of Jenky\\Atlas\\Contracts\\ConnectorInterface and additional constructor arguments that you need for all request grouped under the resource."]},{"l":"Defining a Resource On Your Connector","p":["Now we'll define a method on the connector which returns this resource class. Don't forget to pass the connector's instance ($this) into the resource."]},{"l":"Using the Resource","p":["Now all our users have to do is access the org() method on the SDK class to get access to all the various requests that our SDK has to offer."]}],[{"l":"Testing","p":["When testing HTTP clients, you often need to simulate specific scenarios like returning a successful response, returning an error, or returning specific responses in a certain order. Because unit tests need to be predictable, easy to bootstrap, and fast, hitting an actual remote API is a not a good idea. It make your test run slower, wasting the rate limiting and eventually might getting blocked by remote API.","Thanks to the PSR-18 Client and Atlas being client agnostic, testing is easy by just replacing the underlying client with a mock client. Atlas has a dedicated mock client for testing, you can read the full document at Atlas Mock Client."]}]]